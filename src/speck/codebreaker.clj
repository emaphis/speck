(ns codebreaker
  (:require [clojure.spec.alpha :as s]
            [clojure.spec.test.alpha :as stest]))

;; Tutorial
;; http://blog.cognitect.com/blog/2016/10/5/interactive-development-with-clojurespec


;;; start with just the spec for the arguments, and a couple of
;;  supporting definitions.

(def peg? #{:y :g :r :c :w :b})
(s/def ::code (s/coll-of peg? :min-count 4 :max-count 6))

(s/fdef score
  :args (s/cat :secret ::code :guess ::code))

#_(s/exercise (:args (s/get-spec `score)))


;;; specify one of the properties described earlier:
;;  the two codes should be of equal length. 
(s/fdef score
  :args (s/and (s/cat :secret ::code :guess ::code)
               (fn [{:keys [secret guess]}]
                 (= (count secret) (count guess)))))

#_(s/exercise (:args (s/get-spec `score)))


;;;  spec the :ret spec.

(s/def ::exact-matches nat-int?)
(s/def ::loose-matches nat-int?)

(s/fdef score
  :args (s/and (s/cat :secret ::code :guess ::code)
               (fn [{:keys [secret guess]}]
                 (= (count secret) (count guess))))
  :ret (s/keys :req [::exact-matches ::loose-matches]))

#_(s/exercise (:args (s/get-spec `score)))

;; some values are too high.
;; map keys are correct but the map values may exceed the number of pegs
;; in the code, violating one of the properties we laid out earlier:
;; the sum of the values in the returned map should be between 0 and the
;; count of either of the codes.

;; The values generated by the :ret spec are always >= 0 because they are
;; spec'd with nat-int?, and their sum is therefore always >= 0, but we
;; can't specify that the sum is >= the number of pegs without knowing
;; the number of pegs, and that information is in the :args spec, which
;; is not exposed to the :ret spec.

;;; For relationships between :args and :ret values, we use a :fn spec:

(s/fdef score
  :args (s/and (s/cat :secret ::code :guess ::code)
               (fn [{:keys [secret guess]}]
                 (= (count secret) (count guess))))
  :ret (s/keys :req [::exact-matches ::loose-matches])
  :fn (fn [{{secret :secret} :args ret :ret}]
        (<= 0 (apply + (vals ret)) (count secret))))

#_(s/exercise-fn #'score)


;; Now we need an actual function to test:
(defn score [secret guess]
  {::exact-matches 0
   ::loose-matches 0})

#_(s/exercise-fn `score)
#_(stest/check `score)

;; This passes but the return values are useless.


;;; Now try dummy data to test for failure.

(defn score [secret guess]
  {::exact-matches 4
   ::loose-matches 3})

#_(s/exercise-fn `score)
#_(stest/check `score)
;; fails


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; calculate exact matches
;;  - we need to compare each peg in the guess to the peg in the same
;; position in the secret:

(defn score [secret guess]
  {::exact-matches  (count (filter true? (map = secret guess)))
   ::loose-matches 0})

#_(s/exercise-fn `score)
;; lots of useful data.
#_(stest/check `score)


;;;;;;;;;;;;;;;;;
;;; extract exact matches function and spec it.

(defn exact-matches [secret guess]
  (count (filter true? (map = secret guess))))

(defn score [secret guess]
  {::exact-matches (exact-matches secret guess)
   ::loose-matches 0})


;;; exact-matches and score have same arguments so extract their spec.

(s/def ::secret-and-guess
  (s/and (s/cat :secret ::code :guess ::code)
         (fn [{:keys [secret guess]}]
           (= (count secret) (count guess)))))

(s/fdef score
  :args ::secret-and-guess
  :ret (s/keys :req [::exact-matches ::loose-matches])
  :fn (fn [{{secret :secret} :args ret :ret}]
        (<= 0 (apply + (vals ret)) (count secret))))

(s/fdef exact-matches
  :args ::secret-and-guess
  :ret nat-int?
  :fn (fn [{{secret :secret} :args ret :ret}]
        (<= 0 ret (count secret))))

;; now test
#_(s/exercise-fn `exact-matches)
#_(stest/check `exact-matches)

;;; since we have working code, we can start instrumenting and testing
(stest/instrument `exact-matches)
(s/exercise-fn `score)
(stest/check `score)


;;;;;;;;;;;;;;;;;;;;;;;;
;; now introduce a bug
(defn score [secret guess]
  {::exact-matches (exact-matches secret (take 3 guess))
   ::loose-matches 0})

;; and this will expose it:
#_(s/exercise-fn `score)


;; remove bug
(defn score [secret guess]
  {::exact-matches (exact-matches secret guess)
   ::loose-matches 0})


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Define all-matches

;;; generalize exact-matches since it has the same properties as
;;  all-matches
(s/fdef match-count
  :args ::secret-and-guess
  :ret? nat-int?
  :fn (fn [{{secret :secret} :args ret :ret}]
        (<= 0 ret (count secret))))

;; use match-count spec for exact-matches function
#_(s/exercise-fn `exact-matches 10 (s/get-spec `match-count))
#_(stest/check-fn exact-matches (s/get-spec `match-count))

;; and instrument exact-matches with generalized spec
#_(stest/instrument `exact-matches
                    {:spec {`exact-matches (s/get-spec `exact-matches)}})

#_(s/exercise-fn `score)
#_(stest/check `score)


;;; Now create all-matches
;;  We need to allow for duplicates, so we can count the number of
;;  appearances of e.g. :r in the secret and the guess and take the lower
;;  of the two numbers. Then we can do the same for all the colors and
;;  add up the resulting counts.
(defn all-matches [secret guess]
  (apply + (vals (merge-with min
                             (select-keys (frequencies secret) guess)
                             (select-keys (frequencies guess) secret)))))

#_(s/exercise-fn `all-matches 10 (s/get-spec `match-count))


;;; Now put all-matches to work:

(defn score [secret guess]
  (let [exact (exact-matches secret guess)
        all   (all-matches secret guess)]
    {::exact-matches exact
     ::loose-matches (- all exact)}))


(stest/instrument [`exact-matches `all-matches]
                  {:spec {`exact-matches (s/get-spec `match-count)
                          `all-matches (s/get-spec `match-count)}})

(stest/summarize-results (stest/check 'codebreaker/score))
;; => {:total 1, :check-passed 1}

(let [result (stest/summarize-results (stest/check 'codebreaker/score))]
  (and (= (:total result) (:check-passed result))
       (not (contains? result :check-failed))))
;; => true

;; original example
(score [:r :y :g :c] [:c :y :g :b])
;; => #:codebreaker{:exact-matches 2, :loose-matches 1}
